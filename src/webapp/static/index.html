<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PKMN Autoshine - Macro Control</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/dracula.min.css">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/static/styles.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/shell/shell.min.js"></script>

</head>
<body>
  <div class="container">
    <header class="header">
      <div class="header-left">
        <h1><i class="fas fa-gamepad"></i> PKMN Autoshine</h1>
        <p class="subtitle">Advanced Pok√©mon Macro Automation Control</p>
      </div>
      <div class="header-right">
        <button id="settings-toggle" class="settings-btn" title="Settings">
          <i class="fas fa-cog"></i>
        </button>
      </div>
    </header>

    <!-- Macro Status Section -->
    <div class="card macro-status-panel">
      <h2><i class="fas fa-chart-line"></i> Macro Status</h2>
      <div class="status-section">
        <div class="status-item">
          <span class="status-label">Iteration:</span>
          <span class="status-value" id="iteration_count">0</span>
        </div>
        <div class="status-item">
          <span class="status-label">Runtime:</span>
          <span class="status-value" id="runtime_display">0:00</span>
        </div>
        <div class="status-item">
          <span class="status-label">Time/Iteration:</span>
          <span class="status-value" id="time_per_iteration">--</span>
        </div>
      </div>
    </div>

    <!-- Macro Controls Section -->
    <div class="card macro-control-panel">
      <h2><i class="fas fa-play-circle"></i> Macro Controls</h2>
      
      <!-- Macro Selection -->
      <div class="controls-section">
        <div class="macro-selector">
          <div class="form-group">
            <select id="macro_select">
              <option value="">Choose a macro...</option>
            </select>
          </div>
        </div>
        <div class="macro-actions">
          <button id="run_macro" class="success"><i class="fas fa-rocket"></i> Run</button>
          <button id="run_once" class="primary"><i class="fas fa-play"></i> Run Once</button>
          <button id="pause" class="warning"><i class="fas fa-pause"></i> Pause</button>
          <button id="force_stop" class="danger"><i class="fas fa-stop-circle"></i> Force Stop</button>
          <button id="edit_macro" class="secondary"><i class="fas fa-edit"></i> Edit</button>
          <button id="new_macro" class="secondary"><i class="fas fa-plus"></i> New</button>
        </div>
      </div>

    </div>

    <!-- Live Logs -->
    <div class="card logs-panel">
      <div class="logs-header">
        <h2><i class="fas fa-terminal"></i> Live Logs</h2>
        <button id="clear-log" class="btn-small"><i class="fas fa-trash"></i> Clear</button>
      </div>
      <div class="logs-content" id="log">Waiting for connection...</div>
    </div>
  </div>
  <script>
    // Global variables
    let editor;
    let ws;
    let wsReconnectInterval;
    let currentMacroName = '';
    let alertIntervalUserModified = false;

    // Utility function to detect mobile devices
    function isMobileDevice() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
             ('ontouchstart' in window) ||
             (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
    }

    // Check if we should use the fallback editor
    function shouldUseFallback() {
      // Check for problematic mobile browsers or user preference
      const userAgent = navigator.userAgent.toLowerCase();
      const isProblematicBrowser = userAgent.includes('chrome') && userAgent.includes('mobile');
      
      // Check localStorage for user preference
      const preferFallback = localStorage.getItem('useFallbackEditor') === 'true';
      
      return preferFallback || isProblematicBrowser;
    }

    // Initialize fallback editor for mobile
    function initializeFallbackEditor() {
      const wrapper = document.getElementById('editor-wrapper');
      const fallbackEditor = document.getElementById('mobile-fallback-editor');
      
      wrapper.classList.add('use-fallback');
      
      // Add helpful placeholder for mobile users
      fallbackEditor.placeholder = `Enter your macro commands here...

Available commands:
PRESS <button>     - Press a button (a, b, x, y, l, r, zl, zr, plus, minus, home, capture)
STICK <stick> <x> <y> - Move analog stick (l or r, coordinates -1.0 to 1.0)
SLEEP <seconds>    - Wait for specified time

Example:
PRESS a
SLEEP 0.5
STICK l 0.0 1.0
SLEEP 0.1`;

      // Set up fallback editor as the main editor interface
      editor = {
        getValue: function() {
          return fallbackEditor.value;
        },
        setValue: function(value) {
          fallbackEditor.value = value;
        },
        getWrapperElement: function() {
          return fallbackEditor;
        },
        refresh: function() {
          // No-op for regular textarea
        },
        focus: function() {
          fallbackEditor.focus();
        }
      };

      // Add a button to switch back to CodeMirror if desired
      const switchButton = document.createElement('button');
      switchButton.textContent = 'üîÑ Try Advanced Editor';
      switchButton.style.cssText = `
        position: absolute;
        top: 5px;
        right: 5px;
        background: var(--accent-primary);
        color: white;
        border: none;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        cursor: pointer;
        z-index: 1000;
      `;
      
      wrapper.style.position = 'relative';
      wrapper.appendChild(switchButton);
      
      switchButton.onclick = function() {
        localStorage.setItem('useFallbackEditor', 'false');
        location.reload();
      };

      addLogMessage('üì± Using mobile-optimized editor', 'info');
    }

    // Initialize CodeMirror with custom syntax highlighting
    function initializeEditor() {
      // Check if we should use the mobile fallback
      if (isMobileDevice() && shouldUseFallback()) {
        initializeFallbackEditor();
        return;
      }

      // Define custom mode for macro syntax
      CodeMirror.defineMode("macro", function() {
        return {
          token: function(stream, state) {
            // Comments
            if (stream.match(/^#.*/)) {
              return "comment";
            }
            
            // Commands
            if (stream.match(/^(PRESS|STICK|SLEEP)\b/)) {
              return "keyword";
            }
            
            // Button names
            if (stream.match(/\b(a|b|x|y|l|r|zl|zr|plus|minus|home|capture|ls|rs)\b/)) {
              return "atom";
            }
            
            // Numbers (coordinates, time values)
            if (stream.match(/[-+]?\d*\.?\d+/)) {
              return "number";
            }
            
            // Strings
            if (stream.match(/^"([^"\\]|\\.)*"/)) {
              return "string";
            }
            
            stream.next();
            return null;
          }
        };
      });

      // Use different input methods for mobile vs desktop
      const isMobile = isMobileDevice();
      const editorConfig = {
        mode: 'macro',
        theme: 'dracula',
        lineNumbers: true,
        indentUnit: 2,
        lineWrapping: true,
        autoCloseBrackets: true,
        matchBrackets: true,
        showCursorWhenSelecting: true,
        tabSize: 2,
        extraKeys: {
          "Ctrl-S": function() { saveMacro(); },
          "Cmd-S": function() { saveMacro(); }
        }
      };

      // Add mobile-specific configuration
      if (isMobile) {
        editorConfig.inputStyle = "textarea";  // Use textarea input for better mobile support
        editorConfig.spellcheck = false;
        editorConfig.autocorrect = false;
        editorConfig.autocapitalize = false;
        editorConfig.lineWiseCopyCut = false;
        editorConfig.undoDepth = 200;
      } else {
        editorConfig.inputStyle = "contenteditable";
        // Add desktop backspace handler
        editorConfig.extraKeys["Backspace"] = function(cm) {
          const cursor = cm.getCursor();
          if (cursor.ch === 0 && cursor.line > 0) {
            const prevLine = cm.getLine(cursor.line - 1);
            const prevLineEnd = prevLine.length;
            cm.replaceRange("", 
              {line: cursor.line - 1, ch: prevLineEnd}, 
              {line: cursor.line, ch: 0}
            );
          } else {
            return CodeMirror.Pass;
          }
        };
      }

      editor = CodeMirror.fromTextArea(document.getElementById('macro_editor'), editorConfig);

      // Setup mobile support function
      function setupMobileSupport(cm) {
        let lastContent = cm.getValue();
        let isHandlingInput = false;

        // Handle virtual keyboard changes on mobile
        cm.on('focus', function() {
          setTimeout(() => {
            if (window.visualViewport) {
              const handleViewportChange = () => {
                const editorElement = cm.getWrapperElement();
                const rect = editorElement.getBoundingClientRect();
                if (rect.bottom > window.visualViewport.height) {
                  editorElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
              };
              window.visualViewport.addEventListener('resize', handleViewportChange);
            }
          }, 100);
        });

        // Monitor content changes for backspace detection
        cm.on('beforeChange', function(cm, changeObj) {
          if (isHandlingInput) return;
          
          const cursor = cm.getCursor();
          const currentContent = cm.getValue();
          
          // Check if this is a backspace operation at line beginning
          if (changeObj.origin === '+delete' && 
              changeObj.from.line > 0 && 
              changeObj.from.ch === 0 && 
              changeObj.to.ch === 0) {
            
            isHandlingInput = true;
            changeObj.cancel();
            
            // Manually handle line merging
            setTimeout(() => {
              const prevLine = cm.getLine(changeObj.from.line - 1);
              const currentLine = cm.getLine(changeObj.from.line);
              const prevLineEnd = prevLine.length;
              
              // Replace the newline with nothing, merging the lines
              cm.replaceRange(currentLine, 
                {line: changeObj.from.line - 1, ch: prevLineEnd}, 
                {line: changeObj.from.line + 1, ch: 0}
              );
              
              // Set cursor position at the merge point
              cm.setCursor({line: changeObj.from.line - 1, ch: prevLineEnd});
              
              isHandlingInput = false;
            }, 0);
          }
        });

        // Direct input monitoring as fallback
        const textarea = cm.getInputField();
        if (textarea) {
          textarea.addEventListener('input', function(e) {
            if (isHandlingInput) return;
            
            setTimeout(() => {
              const newContent = cm.getValue();
              const cursor = cm.getCursor();
              
              // Detect if lines were merged (content got shorter and we're at start of line)
              if (newContent.length < lastContent.length && cursor.ch === 0 && cursor.line > 0) {
                const lines = newContent.split('\n');
                const lastLines = lastContent.split('\n');
                
                // If we lost a line, it might be a backspace at line start
                if (lines.length < lastLines.length) {
                  cm.refresh();
                }
              }
              
              lastContent = newContent;
            }, 0);
          });

          // Handle keydown events directly on the textarea
          textarea.addEventListener('keydown', function(e) {
            if (e.key === 'Backspace' || e.keyCode === 8) {
              const cursor = cm.getCursor();
              
              // If at the beginning of a line
              if (cursor.ch === 0 && cursor.line > 0) {
                e.preventDefault();
                isHandlingInput = true;
                
                const prevLine = cm.getLine(cursor.line - 1);
                const currentLine = cm.getLine(cursor.line);
                const prevLineEnd = prevLine.length;
                
                // Merge lines
                cm.replaceRange(prevLine + currentLine, 
                  {line: cursor.line - 1, ch: 0}, 
                  {line: cursor.line + 1, ch: 0}
                );
                
                // Position cursor at merge point
                cm.setCursor({line: cursor.line - 1, ch: prevLineEnd});
                
                setTimeout(() => {
                  isHandlingInput = false;
                  cm.refresh();
                }, 10);
              }
            }
          });
        }

        // Handle orientation changes
        window.addEventListener('orientationchange', () => {
          setTimeout(() => {
            cm.refresh();
          }, 200);
        });

        // Force periodic refresh on mobile
        setInterval(() => {
          if (document.activeElement === textarea) {
            cm.refresh();
          }
        }, 1000);
      }

      // Add custom CSS for macro syntax highlighting
      const style = document.createElement('style');
      style.textContent = `
        .cm-s-dracula .cm-keyword { color: #ff79c6; font-weight: bold; }
        .cm-s-dracula .cm-atom { color: #8be9fd; }
        .cm-s-dracula .cm-number { color: #bd93f9; }
        .cm-s-dracula .cm-comment { color: #6272a4; font-style: italic; }
      `;
      document.head.appendChild(style);

      // Add mobile-specific event handling
      if (isMobileDevice()) {
        setupMobileSupport(editor);
        
        // Additional fallback: mutation observer for content changes
        const wrapper = editor.getWrapperElement();
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.type === 'childList' || mutation.type === 'characterData') {
              // Force a refresh after DOM changes
              setTimeout(() => editor.refresh(), 10);
            }
          });
        });
        
        observer.observe(wrapper, {
          childList: true,
          subtree: true,
          characterData: true
        });

        // Detect persistent backspace issues and offer fallback
        let backspaceProblemCount = 0;
        const textarea = editor.getInputField();
        
        if (textarea) {
          textarea.addEventListener('keydown', function(e) {
            if (e.key === 'Backspace' && editor.getCursor().ch === 0 && editor.getCursor().line > 0) {
              backspaceProblemCount++;
              
              if (backspaceProblemCount >= 3) {
                setTimeout(() => {
                  if (confirm('Having trouble with backspace? Switch to mobile-optimized editor?')) {
                    localStorage.setItem('useFallbackEditor', 'true');
                    location.reload();
                  }
                }, 500);
              }
            }
          });
        }
      }
    }

    // WebSocket management
    function connectWebSocket() {
      const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${wsProtocol}//${location.host}/ws`);
      
      const wsIndicator = document.getElementById('ws-indicator');
      const wsStatus = document.getElementById('ws-status');
      
      ws.onopen = () => {
        console.log('WebSocket connected');
        wsIndicator.classList.add('connected');
        wsStatus.textContent = 'Connected';
        clearInterval(wsReconnectInterval);
        addLogMessage('üü¢ Connected to server', 'success');
      };

      ws.onclose = () => {
        console.log('WebSocket disconnected');
        wsIndicator.classList.remove('connected');
        wsStatus.textContent = 'Disconnected';
        addLogMessage('üî¥ Disconnected from server', 'error');
        
        // Auto-reconnect
        wsReconnectInterval = setInterval(() => {
          addLogMessage('üîÑ Attempting to reconnect...', 'info');
          connectWebSocket();
        }, 5000);
      };

      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        addLogMessage('‚ùå Connection error', 'error');
      };

      ws.onmessage = (e) => {
        try {
          const msg = JSON.parse(e.data);
          handleWebSocketMessage(msg);
        } catch (error) {
          console.error('Failed to parse WebSocket message:', error);
        }
      };
    }

    function handleWebSocketMessage(msg) {
      if (msg.type === 'log') {
        addLogMessage(msg.message || msg.msg, msg.level || 'info');
      } else if (msg.type === 'status') {
        updateStatus(msg);
      } else if (msg.type === 'alert') {
        showAlert(msg.iterations);
      }
    }

    // Status management
    async function updateMacroDetails() {
      try {
        const res = await fetch('/api/status');
        if (!res.ok) return;
        
        const status = await res.json();
        
        // Update individual status fields
        document.getElementById('iteration_count').textContent = status.iterations || 0;
        document.getElementById('runtime_display').textContent = status.runtime || '0:00';
        document.getElementById('time_per_iteration').textContent = status.sec_per_iter ? status.sec_per_iter + 's' : '--';
        
        // Check for pending alert
        if (status.pending_alert && status.iterations > 0) {
          showAlert(status.iterations);
        }
        
        // Update alert interval UI if it changed (but don't overwrite if user has modified it)
        if (status.alert_interval !== undefined && !alertIntervalUserModified) {
          const alertInput = document.getElementById('alert_interval');
          // Only update if the input is not currently focused
          if (document.activeElement !== alertInput) {
            alertInput.value = status.alert_interval;
          }
        }
      } catch (error) {
        console.error('Failed to update macro details:', error);
      }
    }

    async function updateAdapterStatus() {
      try {
        const res = await fetch('/api/adapters/status');
        if (!res.ok) return;
        
        const status = await res.json();
        const preferred = status.preferred || 'auto-detect';
        const connectivity = status.connectivity || {};
        
        const statusLines = [
          `üîå Adapter: ${preferred}`,
          `${connectivity.pico ? '‚úÖ' : '‚ùå'} Pico W: ${connectivity.pico ? 'Available' : 'Unavailable'}`,
          `${connectivity.joycontrol ? '‚úÖ' : '‚ùå'} Joycontrol: ${connectivity.joycontrol ? 'Available' : 'Unavailable'}`
        ];
        
        document.getElementById('adapter_status').textContent = statusLines.join('\n');
        document.getElementById('adapter_select').value = status.preferred || '';
        
        // Update status card styling
        const adapterCard = document.getElementById('adapter_status').closest('.status-card');
        if (connectivity.pico || connectivity.joycontrol) {
          adapterCard.classList.remove('error');
          adapterCard.classList.add('success');
        } else {
          adapterCard.classList.remove('success');
          adapterCard.classList.add('error');
        }
      } catch (error) {
        console.error('Failed to update adapter status:', error);
      }
    }

    function updateStatus(data) {
      // Handle both old string format and new structured data
      if (typeof data === 'string') {
        document.getElementById('macro_status').textContent = data;
        return;
      }
      
      // Update iteration counter, runtime and time per iteration in main display
      if (data.iterations !== undefined) {
        document.getElementById('iteration_count').textContent = data.iterations;
      }
      if (data.runtime) {
        document.getElementById('runtime_display').textContent = data.runtime;
      }
      if (data.sec_per_iter !== undefined) {
        document.getElementById('time_per_iteration').textContent = data.sec_per_iter ? data.sec_per_iter + 's' : '--';
      }
      
      // Update console status with MAC address if available (in settings)
      if (data.console_mac) {
        document.getElementById('console_status').textContent = `${data.console_type || 'Switch'} (${data.console_mac})`;
      } else if (data.adapter_name) {
        document.getElementById('console_status').textContent = data.adapter_name + ' - No console connected';
      } else {
        document.getElementById('console_status').textContent = 'No adapter connected';
      }
      
      // Update macro status (in settings)
      if (data.status) {
        document.getElementById('macro_status').textContent = data.status;
      }
      
      // Update adapter status in settings
      if (data.adapter_name) {
        document.getElementById('adapter_status').textContent = data.adapter_name;
      }
    }

    // Log management with 20 entry limit and spam filtering
    let logEntries = [];
    let lastLogMessage = '';
    let logRepeatCount = 0;
    const MAX_LOG_ENTRIES = 20;
    const SPAM_MESSAGES = [
      'Could not find Pico W device',
      'No module named \'joycontrol\'',
      'Could not connect to any adapter',
      'Attempting to reconnect',
      'WebSocket disconnected'
    ];
    
    function isSpamMessage(message) {
      return SPAM_MESSAGES.some(spam => message.includes(spam));
    }
    
    function addLogMessage(message, type = 'info') {
      // Filter out spam messages after first occurrence
      if (isSpamMessage(message)) {
        if (message === lastLogMessage) {
          logRepeatCount++;
          // Only show repeated spam messages every 10th occurrence
          if (logRepeatCount % 10 !== 0) {
            return;
          }
          message = `${message} (repeated ${logRepeatCount} times)`;
        } else {
          logRepeatCount = 1;
        }
      } else {
        logRepeatCount = 0;
      }
      
      lastLogMessage = message;
      
      const timestamp = new Date().toLocaleTimeString();
      const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : type === 'info' ? '‚ÑπÔ∏è' : type === 'warning' ? '‚ö†Ô∏è' : 'üìù';
      const logEntry = `[${timestamp}] ${prefix} ${message}`;
      
      logEntries.push(logEntry);
      
      // Keep only the latest 20 entries
      if (logEntries.length > MAX_LOG_ENTRIES) {
        logEntries = logEntries.slice(-MAX_LOG_ENTRIES);
      }
      
      // Update display
      const logContent = document.getElementById('log');
      logContent.textContent = logEntries.join('\n');
      logContent.scrollTop = logContent.scrollHeight;
    }

    function clearLog() {
      logEntries = [];
      document.getElementById('log').textContent = '';
      addLogMessage('Log cleared');
    }

    // Macro management
    async function listMacros() {
      try {
        const res = await fetch('/api/macros');
        if (!res.ok) return;
        
        const names = await res.json();
        
        // Populate macro dropdown
        const select = document.getElementById('macro_select');
        select.innerHTML = '<option value="">Choose a macro...</option>';
        
        names.forEach(name => {
          const option = document.createElement('option');
          option.value = name;
          option.textContent = name;
          select.appendChild(option);
        });
      } catch (error) {
        console.error('Failed to list macros:', error);
        addLogMessage('Failed to load macro list', 'error');
      }
    }

    async function loadMacro(name) {
      if (!name) return;
      
      try {
        const res = await fetch(`/api/macros/${encodeURIComponent(name)}`);
        if (!res.ok) throw new Error(`Failed to load macro: ${res.status}`);
        
        const content = await res.text();
        editor.setValue(content);
        document.getElementById('macro_name').value = name;
        currentMacroName = name;
        
        addLogMessage(`Loaded macro: ${name}`, 'success');
      } catch (error) {
        console.error('Failed to load macro:', error);
        addLogMessage(`Failed to load macro: ${name}`, 'error');
      }
    }

    async function saveMacro() {
      const name = document.getElementById('macro_name').value.trim();
      const content = editor.getValue();
      
      if (!name) {
        addLogMessage('Please enter a filename', 'error');
        return;
      }
      
      if (!name.endsWith('.txt')) {
        document.getElementById('macro_name').value = name + '.txt';
      }
      
      try {
        const res = await fetch('/api/macros', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ name: name.endsWith('.txt') ? name : name + '.txt', content })
        });
        
        if (!res.ok) throw new Error(`Save failed: ${res.status}`);
        
        await listMacros();
        currentMacroName = name;
        addLogMessage(`Saved macro: ${name}`, 'success');
        
        // Update select dropdown
        document.getElementById('macro_select').value = name;
        
        // Close modal
        hideModal();
      } catch (error) {
        console.error('Failed to save macro:', error);
        addLogMessage(`Failed to save macro: ${error.message}`, 'error');
      }
    }

    function newMacro() {
      if (editor) {
        editor.setValue('# New macro\n# Enter your commands here...\n\n');
      }
      document.getElementById('macro_name').value = '';
      currentMacroName = '';
      document.getElementById('modal-title').innerHTML = '<i class="fas fa-plus"></i> Create New Macro';
      showModal();
      addLogMessage('Creating new macro', 'info');
    }

    async function runMacro() {
      const selectedMacro = document.getElementById('macro_select').value;
      
      if (!selectedMacro) {
        addLogMessage('Please select a macro to run', 'error');
        return;
      }
      
      try {
        const res = await fetch('/api/select', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ name: selectedMacro })
        });
        
        if (!res.ok) throw new Error(`Failed to run macro: ${res.status}`);
        
        addLogMessage(`Started macro: ${selectedMacro}`, 'success');
      } catch (error) {
        console.error('Failed to run macro:', error);
      }
    }

    async function runOnce() {
      const selectedMacro = document.getElementById('macro_select').value;
      
      if (!selectedMacro) {
        addLogMessage('Please select a macro to run once', 'error');
        return;
      }
      
      try {
        const res = await fetch('/api/run-once', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ name: selectedMacro })
        });
        
        if (!res.ok) throw new Error(`Failed to run macro once: ${res.status}`);
        
        addLogMessage(`Running macro once: ${selectedMacro}`, 'success');
      } catch (error) {
        console.error('Failed to run macro once:', error);
        addLogMessage(`Failed to run macro once: ${selectedMacro}`, 'error');
        addLogMessage(`Failed to run macro: ${error.message}`, 'error');
      }
    }

    // Modal functions
    function showModal() {
      document.getElementById('macro-modal').style.display = 'flex';
      setTimeout(() => {
        if (editor && editor.refresh) {
          editor.refresh();
          editor.focus();
        }
      }, 100);
    }
    
    function hideModal() {
      document.getElementById('macro-modal').style.display = 'none';
    }
    
    // Settings modal functions
    function showSettings() {
      // Reset the alert interval modification flag when opening settings
      alertIntervalUserModified = false;
      document.getElementById('settings-modal').style.display = 'flex';
    }
    
    function hideSettings() {
      document.getElementById('settings-modal').style.display = 'none';
    }
    
    async function editMacro() {
      const selectedMacro = document.getElementById('macro_select').value;
      if (!selectedMacro) {
        addLogMessage('Please select a macro to edit', 'warning');
        return;
      }
      
      try {
        const res = await fetch(`/api/macro/${encodeURIComponent(selectedMacro)}`);
        if (res.ok) {
          const content = await res.text();
          if (editor) {
            editor.setValue(content);
          }
          document.getElementById('macro_name').value = selectedMacro;
          document.getElementById('modal-title').innerHTML = '<i class="fas fa-edit"></i> Edit Macro: ' + selectedMacro;
          showModal();
        } else {
          addLogMessage('Failed to load macro', 'error');
        }
      } catch (error) {
        addLogMessage('Error loading macro: ' + error.message, 'error');
      }
    }

    // Control functions
    function sendCommand(cmd) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ cmd }));
        addLogMessage(`Sent command: ${cmd}`, 'info');
      } else {
        addLogMessage('Not connected to server', 'error');
      }
    }

    async function resetMetrics() {
      try {
        const res = await fetch('/api/reset-metrics', {
          method: 'POST',
          headers: { 'content-type': 'application/json' }
        });
        
        if (!res.ok) throw new Error(`Failed to reset metrics: ${res.status}`);
        
        // Immediately update the UI
        document.getElementById('iteration_count').textContent = '0';
        document.getElementById('runtime_display').textContent = '0:00';
        document.getElementById('time_per_iteration').textContent = '--';
        
        addLogMessage('Metrics reset successfully', 'success');
      } catch (error) {
        console.error('Failed to reset metrics:', error);
        addLogMessage(`Failed to reset metrics: ${error.message}`, 'error');
      }
    }

    // Alert functions
    async function setAlerts() {
      const interval = parseInt(document.getElementById('alert_interval').value) || 0;
      
      try {
        const res = await fetch('/api/alerts/set', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ alert_interval: interval })
        });
        
        if (!res.ok) throw new Error(`Failed to set alerts: ${res.status}`);
        
        // Reset the user modified flag since the setting was successfully applied
        alertIntervalUserModified = false;
        addLogMessage(`Alert interval set to ${interval} iterations${interval === 0 ? ' (disabled)' : ''}`, 'success');
      } catch (error) {
        console.error('Failed to set alerts:', error);
        addLogMessage(`Failed to set alerts: ${error.message}`, 'error');
      }
    }

    function requestNotificationPermission() {
      if ('Notification' in window && Notification.permission === 'default') {
        Notification.requestPermission().then(permission => {
          if (permission === 'granted') {
            addLogMessage('Browser notifications enabled', 'success');
          } else {
            addLogMessage('Browser notifications denied', 'warning');
            document.getElementById('enable_notifications').checked = false;
          }
        });
      }
    }

    function showAlert(iterations) {
      const enableNotifications = document.getElementById('enable_notifications').checked;
      const enableSound = document.getElementById('enable_sound').checked;
      const pauseOnAlert = document.getElementById('pause_on_alert').checked;
      
      const message = `Macro completed ${iterations} iterations`;
      
      // Show browser notification
      if (enableNotifications && 'Notification' in window && Notification.permission === 'granted') {
        new Notification('PKMN-Autoshine Alert', {
          body: message,
          icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="gold"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>',
          tag: 'iteration-alert',
          requireInteraction: true
        });
      }
      
      // Play sound
      if (enableSound) {
        playAlertSound();
      }
      
      // Pause macro if enabled
      if (pauseOnAlert) {
        ws.send(JSON.stringify({action: 'pause'}));
        addLogMessage(`‚è∏Ô∏è Macro paused automatically due to alert at ${iterations} iterations`, 'warning');
      }
      
      // Also show in log
      addLogMessage(`üîî ${message}`, 'warning');
    }

    function playAlertSound() {
      // Create a simple beep sound using Web Audio API
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
        oscillator.type = 'sine';
        
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
        
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.5);
      } catch (error) {
        console.warn('Could not play alert sound:', error);
      }
    }

    async function setAdapter() {
      const adapter = document.getElementById('adapter_select').value || null;
      
      try {
        const res = await fetch('/api/adapters/select', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ adapter })
        });
        
        if (!res.ok) throw new Error(`Failed to set adapter: ${res.status}`);
        
        const result = await res.json();
        addLogMessage(result.message, 'success');
        await updateAdapterStatus();
      } catch (error) {
        console.error('Failed to set adapter:', error);
        addLogMessage(`Failed to set adapter: ${error.message}`, 'error');
      }
    }

    async function testAdapters() {
      const button = document.getElementById('test_adapters');
      const originalText = button.innerHTML;
      
      button.classList.add('loading');
      button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Testing...';
      
      try {
        addLogMessage('Testing adapter connectivity...', 'info');
        await updateAdapterStatus();
        addLogMessage('Adapter test completed', 'success');
      } catch (error) {
        console.error('Failed to test adapters:', error);
        addLogMessage('Adapter test failed', 'error');
      } finally {
        button.classList.remove('loading');
        button.innerHTML = originalText;
      }
    }

    // Event listeners
    function setupEventListeners() {
      // Control buttons
      document.getElementById('pause').onclick = () => {
        sendCommand('pause');
        // The server should handle stopping the runtime tracking
      };
      document.getElementById('force_stop').onclick = () => {
        sendCommand('force_stop');
        // The server should handle stopping the runtime tracking
      };

      // Macro controls
      document.getElementById('run_macro').onclick = runMacro;
      document.getElementById('run_once').onclick = runOnce;
      document.getElementById('macro_select').onchange = (e) => loadMacro(e.target.value);
      document.getElementById('edit_macro').onclick = editMacro;
      document.getElementById('new_macro').onclick = newMacro;
      document.getElementById('save_macro').onclick = saveMacro;
      
      // Modal controls
      document.getElementById('modal-close').onclick = hideModal;
      document.getElementById('cancel_edit').onclick = hideModal;
      // Removed click-outside-to-close to prevent accidental loss of changes
      // Modal can only be closed via X button, Save, or Cancel buttons
      
      // Settings modal controls
      document.getElementById('settings-toggle').onclick = showSettings;
      document.getElementById('settings-close').onclick = hideSettings;
      document.getElementById('settings_save').onclick = hideSettings;
      document.getElementById('settings-modal').onclick = (e) => {
        if (e.target.id === 'settings-modal') hideSettings();
      };

      // Adapter controls
      document.getElementById('set_adapter').onclick = setAdapter;
      document.getElementById('test_adapters').onclick = testAdapters;

      // Metrics controls
      document.getElementById('reset_metrics').onclick = resetMetrics;

      // Alert controls
      document.getElementById('set_alerts').onclick = setAlerts;
      document.getElementById('enable_notifications').onchange = function() {
        if (this.checked) {
          requestNotificationPermission();
        }
      };
      
      // Alert interval input listeners to prevent automatic updates while user is editing
      const alertIntervalInput = document.getElementById('alert_interval');
      alertIntervalInput.oninput = function() {
        alertIntervalUserModified = true;
      };
      alertIntervalInput.onfocus = function() {
        alertIntervalUserModified = true;
      };

      // Log controls
      document.getElementById('clear-log').onclick = clearLog;

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 's') {
          e.preventDefault();
          saveMacro();
        }
        if (e.key === 'Escape') {
          hideModal();
        }
      });
    }

    // Initialize application
    async function initialize() {
      addLogMessage('Initializing PKMN Autoshine...', 'info');
      
      initializeEditor();
      setupEventListeners();
      connectWebSocket();
      
      // Load initial data
      await Promise.all([
        listMacros(),
        updateAdapterStatus()
      ]);
      
      // Set up periodic updates
      setInterval(updateMacroDetails, 1000);
      setInterval(updateAdapterStatus, 30000);
      
      addLogMessage('Application initialized successfully!', 'success');
    }

    // Start the application when page loads
    document.addEventListener('DOMContentLoaded', initialize);
  </script>

  <!-- Macro Editor Modal -->
  <div id="macro-modal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 id="modal-title"><i class="fas fa-code"></i> Edit Macro</h2>
        <button class="modal-close" id="modal-close">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label for="macro_name">Filename:</label>
          <input id="macro_name" type="text" placeholder="Enter filename.txt" style="width: 100%;">
        </div>
        <div id="editor-wrapper">
          <textarea id="macro_editor" placeholder="# Enter your macro commands here...
# Available commands:
# PRESS <button>     - Press a button (a, b, x, y, l, r, zl, zr, plus, minus, home, capture)
# STICK <stick> <x> <y> - Move analog stick (l or r, coordinates -1.0 to 1.0)  
# SLEEP <seconds>    - Wait for specified time
# LOOP <count>       - Start a loop (repeat commands until ENDLOOP)
# ENDLOOP           - End a loop
# 
# Example:
# PRESS a
# SLEEP 0.5
# LOOP 3
#   STICK l 0.0 1.0
#   SLEEP 0.1
# ENDLOOP"></textarea>
          <textarea id="mobile-fallback-editor" class="mobile-fallback-editor"></textarea>
        </div>
      </div>
      <div class="modal-footer">
        <button id="save_macro" class="success"><i class="fas fa-save"></i> Save</button>
        <button id="cancel_edit" class="secondary">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div id="settings-modal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2><i class="fas fa-cog"></i> Settings</h2>
        <button class="modal-close" id="settings-close">&times;</button>
      </div>
      <div class="modal-body">
        <!-- Alert Configuration -->
        <div class="settings-section">
          <h3><i class="fas fa-bell"></i> Notifications</h3>
          <div class="form-group">
            <label for="alert_interval">Interval (0 = off):</label>
            <div class="input-with-unit">
              <input type="number" id="alert_interval" value="0" min="0" max="10000" step="1" style="width: 80px;">
              <small>iterations</small>
            </div>
          </div>
          <div class="form-group">
            <label>
              <input type="checkbox" id="enable_notifications" checked> Browser alerts
            </label>
          </div>
          <div class="form-group">
            <label>
              <input type="checkbox" id="enable_sound" checked> Sound effects
            </label>
          </div>
          <div class="form-group">
            <label>
              <input type="checkbox" id="pause_on_alert"> Pause on alert
            </label>
          </div>
          <button id="set_alerts"><i class="fas fa-save"></i> Apply</button>
        </div>

        <!-- Metrics Configuration -->
        <div class="settings-section">
          <h3><i class="fas fa-chart-bar"></i> Metrics</h3>
          <div class="form-group">
            <p>Reset iteration count and runtime back to zero:</p>
            <button id="reset_metrics" class="danger"><i class="fas fa-undo"></i> Reset Metrics</button>
          </div>
        </div>

        <!-- Adapter Configuration -->
        <div class="settings-section">
          <h3><i class="fas fa-plug"></i> Adapter</h3>
          <div class="form-group">
            <label for="adapter_select">Controller Type:</label>
            <select id="adapter_select">
              <option value="">Auto-detect (Pico first)</option>
              <option value="pico">Pico W (USB Serial)</option>
              <option value="joycontrol">Joycontrol (Bluetooth)</option>
            </select>
          </div>
          <div class="adapter-status">
            <div class="status-item">
              <span class="status-label">Adapter:</span>
              <span class="status-value" id="adapter_status">Checking...</span>
            </div>
            <div class="status-item">
              <span class="status-label">Console:</span>
              <span class="status-value" id="console_status">Checking connection...</span>
            </div>
            <div class="status-item">
              <span class="status-label">Status:</span>
              <span class="status-value" id="macro_status">Ready</span>
            </div>
          </div>
          <div class="button-group">
            <button id="set_adapter"><i class="fas fa-check"></i> Apply</button>
            <button id="test_adapters"><i class="fas fa-search"></i> Test</button>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button id="settings_save" class="success"><i class="fas fa-check"></i> Close</button>
      </div>
    </div>
  </div>
</body>
</html>
